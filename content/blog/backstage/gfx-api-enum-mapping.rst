How Magnum does GFX API enum mapping
####################################

:date: 2019-02-28
:category: Backstage
:tags: C++, Vulkan, D3D, Metal, OpenGL, flextGL
:summary: Engines supporting more than one graphics backend very often need to
    translate various enum values --- pixel formats, primitive types etc. ---
    from a generic API-agnostic value to the one used by a particular
    implementation, in the fastest-possible and most robust way.

.. role:: s
    :class: m-text m-s

.. note-danger::

    .. class:: m-text m-em m-text-center

    | If I'm using a C-based language, I reserve the right for preprocessor
        abuse.
    | You'll pry the :cpp:`#include`\ s out of my cold, dead hands.

`Previous work`_
================

Historically, before the design of Magnum got reworked to support more than
just one graphics API for the `2018.04 release <{filename}/blog/announcements/2018.04.rst>`_,
things were simple. There was just OpenGL and thus the engine could affort to
directly hardcode the OpenGL-specific values --- so then-named
:dox:`PixelFormat::RGBA <PixelFormat::RGBA8Unorm>` was ``GL_RGBA`` and so on.
This is also the fastest possible way, no big mapping tables, no problems with
slow inverse mapping, just directly aliasing the values.

Second fastest is the approach suggested by `@g_truc <https://twitter.com/g_truc>`_
in `Robust and efficient translations in C++ using tables with zero-based enumerations <https://www.g-truc.net/post-0704.html>`_
--- having zero-based enums and a one-way mapping table, to which you index.
Apart from the mapping table, which needs linear amount of memory scaling with
the number of values, such way has a :math:`\mathcal{O}(1)` time complexity, so
pretty good. However the proposed solution involves adding ugly sentinel values
to the enums and, as the article itself already points out, adding values to
anywhere else than at the end of the enum is very error-prone, not to mention
value reordering, and the only way to avoid that is testing every value. And
you can forget about easy inverse mapping.

`Enter the preprocessor`_
=========================

One potential solution could be to have the mapping table generated by an
external tool (written in Python, let's say) and invoke it as a part of the
build. However --- and as `Our Machinery <https://ourmachinery.com/post/one-button-source-code-builds/#picking-a-language>`_
does as well --- I don't really want to introduce other languages into the
build process, as that raises the barrier for external contributors and users
building from source. The only exception is :gh:`flextGL <mosra/flextgl>`,
because if there's one thing you don't want to do
:abbr:`in C++ <or, well, anywhere>`, it's parsing XML. *(And even in that case,
the generated files are checked in to source control, so it doesn't affect the
build process in any way.)*

In an ideal language, both the enum definition *and* the mapping to all
underlying APIs would be defined in a single place, however since for C++ the
enum definiton should to be put in a documented human-readable header and it's
not feasible to have the header depend on *all* corresponding Vulkan, OpenGL,
D3D etc. enum mappings, just a single place is not possible. But, since we have
the right to abuse a preprocessor, two places are enough:

.. container:: m-row

    .. container:: m-col-m-6 m-nopadt m-nopadr

        .. code-figure::

            .. code:: c++

                enum class PixelFormat: UnsignedInt {
                    R8Unorm,
                    RG8Unorm,
                    RGB8Unorm,
                    RGBA8Unorm,
                    R8Snorm,
                    RG8Snorm,
                    RGB8Snorm,
                    RGBA8Snorm,
                    …

            One will be defining the :dox:`PixelFormat` :cpp:`enum` with
            zero-based values in a desired order (documentation comments
            omitted for brevity)...

            .. class:: m-text m-small m-dim

            Full sources
            `here <https://github.com/mosra/magnum/blob/169031fb7bf30e2c98c81cbf865aa5a4662aa716/src/Magnum/PixelFormat.h#L64>`__.

    .. container:: m-col-m-6 m-nopadt

        .. code-figure::

            .. code:: c++

                #ifdef _c
                _c(R8Unorm, R8_UNORM)
                _c(RG8Unorm, R8G8_UNORM)
                _c(RGB8Unorm, R8G8B8_UNORM)
                _c(RGBA8Unorm, R8G8B8A8_UNORM)
                _c(R8Snorm, R8_SNORM)
                _c(RG8Snorm, R8G8_SNORM)
                _c(RGB8Snorm, R8G8B8_SNORM)
                _c(RGBA8Snorm, R8G8B8A8_SNORM)
                …

            ... and the second place is the actual table in
            ``pixelFormatMapping.hpp`` that maps the values to the underlying
            API, in this case Vulkan.

            .. class:: m-text m-small m-dim

            Full sources
            `here <https://github.com/mosra/magnum/blob/169031fb7bf30e2c98c81cbf865aa5a4662aa716/src/Magnum/Vk/Implementation/formatMapping.hpp#L28>`__.

And now, the actual :s:`magic` preprocessor abuse --- creating the
:math:`\mathcal{O}(1)` mapping table by including the above file inside a C
array definition. After that, the mapping function is simply indexing to it
to return the corresponding :vktype:`Format`:

.. code-figure::

    .. code:: c++

        constexpr VkFormat FormatMapping[] {
            #define _c(input, format) VK_FORMAT_ ## format,
            #include "pixelFormatMapping.hpp"
            #undef _c
        };

        …

        VkFormat vkFormat(const PixelFormat format) {
            CORRADE_ASSERT(UnsignedInt(format) < Containers::arraySize(FormatMapping),
                "Vk::vkFormat(): invalid format" << format, {});
            const VkFormat out = FormatMapping[UnsignedInt(format)];
            return out;
        }

    .. class:: m-text m-small m-dim

    Full source `here <https://github.com/mosra/magnum/blob/169031fb7bf30e2c98c81cbf865aa5a4662aa716/src/Magnum/Vk/Enums.cpp#L55>`__.

Note that the :cpp:`FormatMapping` table is filled only using the second
argument of the :cpp:`_c()` macro. The first is in this case unused, but
will get used for testing.

`Testing`_
----------

As you have probably guessed, the above would work correctly only if
``pixelFormatMapping.hpp`` lists the values in the same order as the
:cpp:`enum` --- and so we seem to be arriving back at the core problem. To
solve this, Magnum reuses *the same* mapping file to test the correct mapping,
by abusing the preprocessor again and :cpp:`#include`-ing the file in a
different context. The essence of the test is in the following snippet:

.. code-figure::

    .. code:: c++

        /* "Touchstone" verification */
        CORRADE_COMPARE(vkFormat(PixelFormat::RGBA8Unorm), VK_FORMAT_R8G8B8A8_UNORM);

        /* Going through the first 16 bits is enough in this case */
        for(UnsignedInt i = 0; i != 0xffff; ++i) {
            PixelFormat format(i);
            #ifdef __GNUC__
            #pragma GCC diagnostic push
            #pragma GCC diagnostic error "-Wswitch"
            #endif
            switch(format) {
                #define _c(format, expectedFormat)                              \
                    case PixelFormat::format:                                   \
                        CORRADE_COMPARE(vkFormat(PixelFormat::format),          \
                                        VK_FORMAT_ ## expectedFormat);          \
                        continue;
                #include "pixelFormatMapping.hpp"
                #undef _c
            }
            #ifdef __GNUC__
            #pragma GCC diagnostic pop
            #endif
        }

    .. class:: m-text m-small m-dim

    Full source `here <https://github.com/mosra/magnum/blob/169031fb7bf30e2c98c81cbf865aa5a4662aa716/src/Magnum/Vk/Test/EnumsTest.cpp#L182>`__.

The :dox:`CORRADE_COMPARE()` macros are part of the :dox:`TestSuite` library.
Let's go through the rest:

1.  First, basic sanity is checked for a single value, in the simplest way
    possible. This ensures the test is still able to detect serious cases of
    the mapping being broken even if the following loop would be giving false
    positives by accident.
2.  Second, it goes through the first 65536 numbers. The :dox:`PixelFormat`
    enum has considerably less values and it will never grow so big, but this
    is a good tradeoff --- going through the whole 32bit range would take too
    long, while going just through 8 bits might become dangerous when more
    formats get added.
3.  For every value that's a part of the mapping table, one :cpp:`case` will
    get hit, verifying that the resulting value corresponds to the expectation.
    This is the first time where the both the first and the second argument of
    the :cpp:`_c()` macro gets used.
4.  Values that are not part of the mapping table get ignored -- in this case,
    that'll be the remaining ~65430 values, since the table has currently only
    about 50 values.
5.  :dox:`PixelFormat` values that were accidentally not added to the
    ``pixelFormatMapping.hpp`` table will cause an error *at compile time*,
    thanks to ``-Werror=switch`` enabled for the :cpp:`switch` on GCC and
    Clang. I'm not aware of a similar compiler warning on MSVC, but usually
    projects are tested on more than one CI and so any error will get caught
    early on.

The actual test code linked above is *slightly* more complex, mainly to provide
better diagnostic in case values got ordered incorrectly --- but nothing that
would make this simplified version less thorough.

`Separate pixel format and type in OpenGL`_
-------------------------------------------

OpenGL, with its historic decision to have pixel formats described by *two
values* instead of just one, is making things slightly more complicated. There
are separate :dox:`GL::pixelFormat()` and :dox:`GL::pixelType()` functions,
returning either :dox:`GL::PixelFormat` or :dox:`GL::PixelType` for given
generic :dox:`PixelFormat`. The mapping data and the table definition look like
this, in comparison:

.. container:: m-row

    .. container:: m-col-m-6 m-nopadt

        .. code-figure::

            .. code:: c++
                :class: m-inverted
                :hl_lines: 2 3 4 5 6 7 8 9

                #ifdef _c
                _c(R8Unorm, Red, UnsignedByte)
                _c(RG8Unorm, RG, UnsignedByte)
                _c(RGB8Unorm, RGB, UnsignedByte)
                _c(RGBA8Unorm, RGBA, UnsignedByte)
                _c(R8Snorm, Red, Byte)
                _c(RG8Snorm, RG, Byte)
                _c(RGB8Snorm, RGB, Byte)
                _c(RGBA8Snorm, RGBA, Byte)
                …

            .. class:: m-text m-small m-dim

            Full source `here <https://github.com/mosra/magnum/blob/169031fb7bf30e2c98c81cbf865aa5a4662aa716/src/Magnum/GL/Implementation/pixelFormatMapping.hpp#L30>`__.

    .. container:: m-col-m-6 m-nopadt m-nopadl

        .. code-figure::

            .. code:: c++
                :class: m-inverted
                :hl_lines: 2 3 5 6 7 9

                constexpr struct {
                    GL::PixelFormat format;
                    GL::PixelType type;
                } FormatMapping[] {
                    #define _c(input, format, type) \
                        {GL::PixelFormat::format,   \
                         GL::PixelType::type},
                    #include "pixelFormatMapping.hpp"
                    #undef _c
                };

            .. class:: m-text m-small m-dim

            Full source `here <https://github.com/mosra/magnum/blob/169031fb7bf30e2c98c81cbf865aa5a4662aa716/src/Magnum/GL/PixelFormat.cpp#L39>`__.

`Handling unsupported values`_
------------------------------

While not the case for Vulkan, not all OpenGL editions support everything from
the :dox:`PixelFormat` enum --- in particular, OpenGL ES 2.0 and WebGL 1 have
no support for integers formats like :dox:`PixelFormat::RGBA8UI`. To handle
this correctly, the mapping table provides specific dummy entries for
unsupported formats:

.. code:: c++
    :class: m-inverted
    :hl_lines: 1 7 8 9 10 11 12 13

    #ifndef MAGNUM_TARGET_GLES2
    _c(R8UI, RedInteger, UnsignedByte)
    _c(RG8UI, RGInteger, UnsignedByte)
    _c(RGB8UI, RGBInteger, UnsignedByte)
    _c(RGBA8UI, RGBAInteger, UnsignedByte)
    …
    #else
    _s(R8UI)
    _s(RG8UI)
    _s(RGB8UI)
    _s(RGBA8UI)
    …
    #endif

Then, the mapping table defines the :cpp:`_s()` macro as follows --- no OpenGL
format has a value of :cpp:`0`, so we use it to denote an "invalid" value.

.. code:: c++
    :class: m-inverted
    :hl_lines: 6 8

    constexpr struct {
        GL::PixelFormat format;
        GL::PixelType type;
    } FormatMapping[] {
        #define _c(input, format, type) {GL::PixelFormat::format, GL::PixelType::type},
        #define _s(input) {GL::PixelFormat{}, GL::PixelType{}},
        #include "pixelFormatMapping.hpp"
        #undef _s
        #undef _c
    };

From the API perspective, the :dox:`GL::pixelFormat()` / :dox:`GL::pixelType()`
APIs assert when encountering unsupported formats (i.e., when the mapping table
gives :cpp:`0` back) and the user is supposed to check for the format presence
on given OpenGL edition using :dox:`GL::hasPixelFormat()` beforehand.

`Implementation-specific enum values`_
======================================

It wouldn't be Magnum if it forced the users to just the defined set of generic
formats and the existing mapping to OpenGL or Vulkan. What if the user needs to
express the intent to use ``GL_RGB565`` data? Or use Magnum together with Apple
Metal, for which the mapping is not implemented at the moment?

Since the 32 bits of the :dox:`PixelFormat` are far from being fullly used
(even 16 bits were more than enough, as noted above), the remaining bits can be
used to wrap an implementation-specific format. Neither of the common GFX APIs
are using the upper bit of the 32bit format value, so it's used to denote
storage of an implementation-specific value. Magnum provides
:dox:`pixelFormatWrap()` and :dox:`pixelFormatUnwrap()` that wrap and unwrap an
implementation-specific value into and from the :dox:`PixelFormat`, and such
values are handled specially when going through the :dox:`GL::pixelFormat()` /
:dox:`Vk::vkFormat()` APIs, so the API gets a correct value in any case.

.. code:: c++

    PixelFormat generic = pixelFormatWrap(VK_FORMAT_R10X6_UNORM_PACK16_KHR);
    VkFormat vulkan = Vk::vkFormat(format); // VK_FORMAT_R10X6_UNORM_PACK16_KHR

Since the implementation-specific enum value is opaque to the implementation,
you need to ensure that you pass a correct value (and not e.g. a GL-specific
enum to Vulkan, for example).

`Inverse mapping`_
==================

While mapping from the generic format to an implementation-specific one is
enough in 90% cases, sometimes it's needed to have the inverse mapping as well.
That's the case for the recently introduced :dox:`DebugTools::screenshot()`,
which queries a pair of
:dox:`GL::AbstractFramebuffer::implementationColorReadFormat()` and
:dox:`implementationColorReadType() <GL::AbstractFramebuffer::implementationColorReadType()>`
and then needs to figure the corresponding generic format for them, because
that's what the image converters understand. Otherwise each
:dox:`*ImageConverter <Trade::AbstractImageConverter>` would need to depend on
GL, Vulkan and others and that's not a sane design decision for a multitude of
reasons, as I painfully realized myself in the past.

Solution? Abuse the ``pixelFormatMapping.hpp`` one more time, and turn each
entry into an :cpp:`if()` that returns corresponding generic value for a
matching pair and a null :dox:`Containers::Optional` otherwise:

.. code-figure::

    .. code:: c++

        GL::PixelFormat format = framebuffer.implementationColorReadFormat();
        GL::PixelType type = framebuffer.implementationColorReadType();
        auto genericFormat = [](GL::PixelFormat format, GL::PixelType type)
                -> Containers::Optional<PixelFormat> {
            #define _c(generic, glFormat, glType)                               \
                if(format == GL::PixelFormat::glFormat &&                       \
                   type == GL::PixelType::glType) return PixelFormat::generic;
            #define _s(generic) return {};
            #include "pixelFormatMapping.hpp"
            #undef _c
            #undef _s
            #endif
            return {};
        }(format, type);

    .. class:: m-text m-small m-dim

    Full source `here <https://github.com/mosra/magnum/blob/169031fb7bf30e2c98c81cbf865aa5a4662aa716/src/Magnum/DebugTools/Screenshot.cpp#L46>`__.

This, in particular, is by no means a fast implementation --- compared to the
forward mapping it's :math:`\mathcal{O}(n)` --- but good enough in this case.
And there's nothing preventing anybody from filling a hash map in a similar
way.

`Enums elsewhere`_
==================

Similar approach as is used for :dox:`PixelFormat` is also used for other
API-specific enums such as :dox:`SamplerFilter` (corresponding to
:dox:`GL::SamplerFilter` or :vktype:`Filter`) or :dox:`MeshPrimitive`
(corresponding to :dox:`GL::MeshPrimitive` or :vktype:`PrimitiveTopology`),
however in that case the mapping is done without preprocessor :s:`magic` abuse,
as there's just a handful of values in each case.

In case of enums in various application implementations (such as
:dox:`Platform::Sdl2Application::KeyEvent::Key`), there the enum is directly
aliasing the underlying value --- so far, for the applications, there was no
need to have a generic interface to them. Instead, the application APIs are
designed with `static polymorphism <static-and-dynamic-polymorphism-in-magnum.rst>`_
in mind, allowing to switch from one to another usually just by using a
different :cpp:`#include`. Interfaces that need to be able to work with any of
these (such as the :dox:`Ui` library or :dox:`ImGuiIntegration`) then use
simple duck typing, by making the input handlers templated.

.. note-dim::

    Discussion: `Twitter <https://twitter.com/czmosra/status/1101209002191523841>`_,
    Reddit `r/cpp <https://www.reddit.com/r/cpp/comments/avvemy/how_magnum_engine_does_gfx_api_enum_mapping/>`_,
    `r/gamedev <https://www.reddit.com/r/gamedev/comments/avvf04/how_magnum_engine_does_gfx_api_enum_mapping/>`_,
    `r/vulkan <https://www.reddit.com/r/vulkan/comments/avvfej/how_magnum_engine_does_gfx_api_enum_mapping_for/>`_,
    `Hacker News <https://news.ycombinator.com/item?id=19274531>`_
